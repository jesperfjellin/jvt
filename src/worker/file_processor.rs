use std::path::Path;
use std::fs::File;
use std::io::{BufRead, BufReader};
use anyhow::{Context, Result};
use tracing::{info, warn, error, debug};
use crate::{TileCoord, Config};
use super::TileBatch;

/// Processor for dirty tiles files generated by OSM2PGSQL
pub struct DirtyTilesProcessor {
    config: Config,
}

impl DirtyTilesProcessor {
    /// Create a new dirty tiles processor
    pub fn new(config: Config) -> Self {
        Self { config }
    }

    /// Process a dirty tiles file and return a tile batch
    pub fn process_file<P: AsRef<Path>>(&self, file_path: P) -> Result<TileBatch> {
        let file_path = file_path.as_ref();
        info!("Processing dirty tiles file: {}", file_path.display());

        // Open and read the file
        let file = File::open(file_path)
            .with_context(|| format!("Failed to open dirty tiles file: {}", file_path.display()))?;

        let reader = BufReader::new(file);
        let mut batch = TileBatch::new(file_path.to_path_buf());
        let mut _line_count = 0;
        let mut error_count = 0;

        // Process each line
        for (line_number, line_result) in reader.lines().enumerate() {
            _line_count += 1;
            
            match line_result {
                Ok(line) => {
                    let line = line.trim();
                    
                    // Skip empty lines and comments
                    if line.is_empty() || line.starts_with('#') {
                        continue;
                    }

                    match self.parse_tile_line(line) {
                        Ok(coord) => {
                            // Filter by max zoom if configured
                            if coord.z <= self.config.tiles.max_zoom {
                                batch.add_tile(coord);
                            } else {
                                debug!("Skipping tile {} (zoom {} > max {})", 
                                      coord.to_string(), coord.z, self.config.tiles.max_zoom);
                            }
                        }
                        Err(e) => {
                            error_count += 1;
                            if error_count <= 10 { // Limit error spam
                                warn!("Line {}: Failed to parse tile coordinate '{}': {}", 
                                      line_number + 1, line, e);
                            } else if error_count == 11 {
                                warn!("More than 10 parse errors, suppressing further warnings...");
                            }
                            
                            // Write to dead letter file if too many errors
                            if error_count <= 100 {
                                self.write_to_dead_letter(&format!("{}:{}", file_path.display(), line))?;
                            }
                        }
                    }
                }
                Err(e) => {
                    error!("Failed to read line {} from {}: {}", 
                           line_number + 1, file_path.display(), e);
                    return Err(e.into());
                }
            }
        }

        let summary = batch.summary();
        info!("Processed dirty tiles file: {}", summary);
        
        if error_count > 0 {
            warn!("Encountered {} parse errors in {}", error_count, file_path.display());
        }

        Ok(batch)
    }

    /// Parse a single line containing a tile coordinate
    fn parse_tile_line(&self, line: &str) -> Result<TileCoord> {
        TileCoord::from_str(line)
            .map_err(|e| anyhow::anyhow!("Invalid tile format: {}", e))
    }

    /// Write unparseable lines to dead letter file for investigation
    fn write_to_dead_letter(&self, line: &str) -> Result<()> {
        use std::io::Write;
        
        let dead_letter_path = &self.config.files.dead_letter_path;
        
        // Create parent directory if needed
        if let Some(parent) = dead_letter_path.parent() {
            std::fs::create_dir_all(parent)
                .context("Failed to create dead letter directory")?;
        }

        let mut file = std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(dead_letter_path)
            .context("Failed to open dead letter file")?;

        writeln!(file, "{}", line)
            .context("Failed to write to dead letter file")?;

        Ok(())
    }

    /// Get the total number of lines in a file (for progress tracking)
    pub fn count_lines<P: AsRef<Path>>(&self, file_path: P) -> Result<usize> {
        let file = File::open(file_path.as_ref())
            .context("Failed to open file for line counting")?;
        
        let reader = BufReader::new(file);
        let count = reader.lines().count();
        
        Ok(count)
    }

    /// Validate that a dirty tiles file exists and is readable
    pub fn validate_file<P: AsRef<Path>>(&self, file_path: P) -> Result<FileInfo> {
        let file_path = file_path.as_ref();
        
        let metadata = std::fs::metadata(file_path)
            .with_context(|| format!("Failed to read metadata for {}", file_path.display()))?;

        if !metadata.is_file() {
            return Err(anyhow::anyhow!("Path is not a file: {}", file_path.display()));
        }

        let size_bytes = metadata.len();
        let line_count = self.count_lines(file_path)?;

        Ok(FileInfo {
            path: file_path.to_path_buf(),
            size_bytes,
            line_count,
            modified: metadata.modified().ok(),
        })
    }
}

#[derive(Debug)]
pub struct FileInfo {
    pub path: std::path::PathBuf,
    pub size_bytes: u64,
    pub line_count: usize,
    pub modified: Option<std::time::SystemTime>,
}

impl std::fmt::Display for FileInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{} ({} bytes, {} lines)", 
               self.path.display(), self.size_bytes, self.line_count)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;

    #[test]
    fn test_process_dirty_tiles_file() {
        // Create a temporary file with test data
        let temp_dir = std::env::temp_dir();
        let test_file = temp_dir.join("test_dirty_tiles.txt");
        
        {
            let mut file = File::create(&test_file).unwrap();
            writeln!(file, "14/8234/5425").unwrap();
            writeln!(file, "12/2058/1356").unwrap();
            writeln!(file, "# This is a comment").unwrap();
            writeln!(file, "").unwrap(); // Empty line
            writeln!(file, "10/515/339").unwrap();
            writeln!(file, "invalid_line").unwrap(); // Should be ignored
        }

        let config = Config::default();
        let processor = DirtyTilesProcessor::new(config);
        
        let batch = processor.process_file(&test_file).unwrap();
        
        assert_eq!(batch.len(), 3); // Should parse 3 valid tiles
        assert_eq!(batch.min_zoom, 10);
        assert_eq!(batch.max_zoom, 14);

        // Clean up
        std::fs::remove_file(test_file).ok();
    }

    #[test]
    fn test_parse_tile_line() {
        let config = Config::default();
        let processor = DirtyTilesProcessor::new(config);
        
        // Valid formats
        assert!(processor.parse_tile_line("14/8234/5425").is_ok());
        assert!(processor.parse_tile_line("0/0/0").is_ok());
        
        // Invalid formats
        assert!(processor.parse_tile_line("invalid").is_err());
        assert!(processor.parse_tile_line("14/8234").is_err());
        assert!(processor.parse_tile_line("14/8234/5425/extra").is_err());
    }
} 